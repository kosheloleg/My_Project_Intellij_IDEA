Не наследуется
1. Поля и методы static,
2. private
3.  и конструкторы


Переопределение это процес замены метода базового класа, своим методом в наследнике
@override - это попросить компилятор проследить переопределения
1. Тип метода должен быть таким же
2. Модификатор доступа не может быть уже
3. Переопределение не может выбрасывать больше исключение

Агрегирование

Делигирование - это такой вид отношений когда один клас перевызывает методы другого класса.


Полиморфизм - это это механизм с помощью которой переменной родительского класса можем ссылатся на объект наследника
Полиморфизм - это способность переменной ссылочного типа иметь разную реализация
Полиморфизм - это возможность работать с объектами разный типов единым образом

Абстрактность - это метод не имеющий реализации
Предполагается что абстрактный метод будет переопределен в наследнике

Интерфейс это конструкция которая задает поведение объекта

Моя теория:
Абстрактный класы позволяют иметь методы абстрактные и не абстрактные

Интерфейс это изначально полностью абстрактный класс
Особенности интерфейсов это множественное наследование;
Поля в интерфейсах по умолчанию static final
Интерфейсы не могут иметь констукторов

Файловая система:

f.exist();
f.isFile();
f.isDirectory();

public class FileTest {
 public static void main(String[] args) throws IOException {
  File f = new File("d://book/1.txt");
  File[] files = f.listFiles();// files.length!!! error
  System.out.println("files="+files);

  System.out.println(Arrays.toString(files));
  System.out.println(f.getCanonicalPath());
  System.out.println(File.separatorChar);
  if(f.isDirectory()) System.out.println("Это директория");
  if(!f.exists()) f.createNewFile();
 }
}
//////////////////////////////////////////////////////////////////////////
Потоки бывают символьные, байтовые
FileWriter fw = new FileWriter("file1.txt");
fw.write("");
fw.flush() -  збрасывает из буфера в файл и гарантировано очищает буфер.
close - содержит flush

FileReader fr = new FileReader("file1.txt");
Scanner scan = new Scanner(fr);

scan.hasNextLine();
scan.nextLine();

scan.close();

while(scan.hasNext()) scan.next();
\n - переход на следующую строку
\t - табуляция