Не наследуется
1. Поля и методы static,
2. private
3.  и конструкторы


Переопределение это процес замены метода базового класа, своим методом в наследнике
@override - это попросить компилятор проследить переопределения
1. Тип метода должен быть таким же
2. Модификатор доступа не может быть уже
3. Переопределение не может выбрасывать больше исключение

Агрегирование

Делигирование - это такой вид отношений когда один клас перевызывает методы другого класса.


Полиморфизм - это это механизм с помощью которой переменной родительского класса можем ссылатся на объект наследника
Полиморфизм - это способность переменной ссылочного типа иметь разную реализация
Полиморфизм - это возможность работать с объектами разный типов единым образом

Абстрактность - это метод не имеющий реализации
Предполагается что абстрактный метод будет переопределен в наследнике

Интерфейс это конструкция которая задает поведение объекта

Моя теория:
Абстрактный класы позволяют иметь методы абстрактные и не абстрактные

Интерфейс это изначально полностью абстрактный класс
Особенности интерфейсов это множественное наследование;
Поля в интерфейсах по умолчанию static final
Интерфейсы не могут иметь констукторов

Файловая система:

f.exist();
f.isFile();
f.isDirectory();

public class FileTest {
 public static void main(String[] args) throws IOException {
  File f = new File("d://book/1.txt");
  File[] files = f.listFiles();// files.length!!! error
  System.out.println("files="+files);

  System.out.println(Arrays.toString(files));
  System.out.println(f.getCanonicalPath());
  System.out.println(File.separatorChar);
  if(f.isDirectory()) System.out.println("Это директория");
  if(!f.exists()) f.createNewFile();
 }
}
//////////////////////////////////////////////////////////////////////////
Потоки бывают символьные, байтовые
FileWriter fw = new FileWriter("file1.txt");
fw.write("");
fw.flush() -  збрасывает из буфера в файл и гарантировано очищает буфер.
close - содержит flush

FileReader fr = new FileReader("file1.txt");
Scanner scan = new Scanner(fr);

scan.hasNextLine();
scan.nextLine();

scan.close();

while(scan.hasNext()) scan.next();
\n - переход на следующую строку
\t - табуляция

////////////////////////Иерархия папок
ArrayList<File> files =
files.add(dir); \\new File

for (int i=0; files.size;i++){

File[] arr = files.get(i).listFiles;

for (int j=0;j<arr...;j++){

if (isDirectiry)

files.add(arr[j])

}
}
}

Вложенные внетренние класы это класы обьявленные внутри другого класса

1. Вложенные(Nested Classes) static!!!
2. Внутренние (Inner Clases)
 - Обычные (Inner)
 - Локальные (Local)  это обьявленные внутри метода, имеет доступ только к локальным переменным только final
 - Анонимные (безимянные) (Anonymous)


 1. Вложенные (Nested Classes) static!!!!
 2. Внутренние (Inner Classes):
     - обычные    (Inner)
     - локальные  (Local)
     - анонимные (безымянные) (Anonymous)


   Методы сортировки
   Пузирек, выборка, вставками, Шела
   Подсчетом,Быстрая сортировка,Слияние

   Поиски
   1. Линейный
   2. Бинарный поиск (Двоичный)
   3. Бинарное дерево поиска


 /////////////////////////////////////////////////////////
 public class MyClass {
  static int sStatic;
  int sNonStatic;
  public static class NestedExmple{
   public void f1(){
   }
  }
  public class InnerExmple{
   public void f2(){
   }
  }
  public static void main(String[] args) {
  }
 }
 public class MainNestedInner {
  public static void main(String[] args) {
   MyClass.NestedExmple obj1 =
     new MyClass.NestedExmple();

   MyClass.InnerExmple obj2 =
     new MyClass().new InnerExmple();
   obj1.f1();
   obj2.f2();
  }
 }

 * Local
  public static void main(String[] args){
   final String name1 = "Name1";
   String name2 = "Name2";

   class InnerLocal{
    public void func(){

     System.out.println(name1 +" "+ nameStatic);
     //System.out.println(name2);//error
   }
   }
  }
 *****

 public class DateExmple {


  public static void main(String[] args) {
   Date d = new Date();
   Calendar c = new GregorianCalendar();
    Calendar c2 = new GregorianCalendar(2014, 12, 20);//календарь на 20 01 2014
   System.out.println("Date: " + d);
   System.out.println("GregorianCalendar: " + d);
   System.out.println("GregorianCalendar: " + c2);

   SimpleDateFormat format1 = new SimpleDateFormat("dd.MM.yyyy hh:mm");
      SimpleDateFormat format2 = new SimpleDateFormat("День dd Месяц MM Год yyyy Время hh:mm");
      SimpleDateFormat format3 = new SimpleDateFormat("dd-M-yyyy");
      //
      System.out.println(" SimpleDateFormat  format1 format2 format3 ");
      System.out.println("1: "+format1.format(d));
      System.out.println("2: "+format2.format(c.getTime()));
      System.out.println("3: "+format3.format(c2.getTime()));
      //
      System.out.println();

         //
      System.out.println("FirstDayOfWeek = "+c.getFirstDayOfWeek());
      System.out.println("TimeZone = "+c.getTimeZone());
         System.out.println("DAY_OF_WEEK = "+Calendar.DAY_OF_WEEK);
         System.out.println("DAY_OF_MONTH = "+Calendar.DAY_OF_MONTH);
         System.out.println("DECEMBER = "+c2.DECEMBER);
         //
         c2.add(Calendar.DAY_OF_YEAR, 1); //увеличиваем дату на 1 день
         System.out.println(c2.getTime());// Fri Feb 21 00:00:00 EET 2014
         c2.add(Calendar.DAY_OF_YEAR, -1); //уменьшаем дату на 1 день
         //
         System.out.println(format3.format(c2.getTime()));//20 02 2014
  }
 }



 [17:34:09] Кузменюк Максим: public enum MyEnum {
  Black, Red, White;
  public void f(){

  }
  public static void g(){

  }
  public static void main(String[] args) {
   System.out.println("Hello !");
  }
 }
 [17:34:17] Кузменюк Максим: public class MyEnumExample {
  public static void main(String[] args) {
   MyEnum obj = MyEnum.Black;
   obj = MyEnum.Red;
   obj.f();
   MyEnum.g();

   MyEnum[] consts = MyEnum.values();
   MyEnum obj1 = MyEnum.valueOf("Black");
   String s = obj1.toString();
  }
 }

Дженерики не работают с примитивным типами

Все класы являются наследниками Object

Олдносвязный список э то спмсок знающий только первый эл.
Эл односвязного списка знают свего соседа

class MyFirstList{
private Element first;
        add(e);
        get(i);
        size()
        print()

}


class Element{
pribate int value;
private Element next

}

Comparable
Comparator


Collections.sort(list);//Comparable
Arrays.sort(vector);//Comparable

public class Car  implements Comparable<Car>{
 private int nomer;
 @Override
 public int compareTo(Car car) {
  return this.nomer - car.getNomer();
 }
}

car1.compareTo(car2)
Comparable: String, Integer, Double, Character, Date, GregorianCalendar
************************************************
Collections.sort(list, new NumberSortCar());//Comparator
Arrays.sort(vector, new NumberSortCar());//Comparator

public class NumberSortCar implements Comparator<Car>{
 @Override
 public int compare(Car car1, Car car2) {
  ...
 }
}
************************************************
public class Car  implements Comparable{
 private int nomer;
 @Override
 public int compareTo(Object obj) {
 Car car = (Car)(obj);
  return this.nomer - car.getNomer();
 }
}
public class Car  implements Comparable<Car>{
 private int nomer;
 @Override
 public int compareTo(Car car) {
  return this.nomer - car.getNomer();
 }
}


cath(Exception e)
    s.o.p. ("AAAA");
    s.o.p. (e.getMessage);
    s.o.p. (e.PrintStackTrace());

                Throwable
          Exception       Error
          RunTimeException


public class Test1Exception {
 public static void main(String[] args) {
  int x = 10;
  //int y = 0;
  double y = 0;
  double res = x/y;
  System.out.println(res);
 }
}
***
public class Test2Exception {
 public static void main(String[] args) {
  int x = 10;
  //int y = 0;
  double y = 0;
  try{
  double res = x/y;
  System.out.println(res);
  } catch (Exception e){
   System.out.println("ОШИБКА !!!!");
   System.out.println(e.getMessage());
   e.printStackTrace();
  }
 }
}
***
public class Test3Exception {
 public static void main(String[] args) {
  throw new ArithmeticException("Ой! Ой! Ой!");
 }
}
***
import java.io.FileNotFoundException;
import java.io.FileReader;

public class Test4Exception {
 public static void f() throws FileNotFoundException {
  FileReader fr = new FileReader("file1.txt");
 }
 public static void main(String[] args) {
  try {
   f();
  } catch (FileNotFoundException e) {

   e.printStackTrace();
  }
 }
}
***
public class Test5Exception {
 public static void main(String[] args) {
  int k = (int)(2*Math.random());
     try {
         int[] a = new int[2];
         a[0] = 22 / 2;
         a[1] = 33 / 3;
         a[2] = 33 / k;
     } catch (ArithmeticException ex) {
         System.out.println("Деление на 0!");
     } catch (ArrayIndexOutOfBoundsException ex) {
         System.out.println("Выход за пределы массива!");
     } catch (Exception ex) {
         System.out.println("Общая ошибка!");
     }
 }
}